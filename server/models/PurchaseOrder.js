const mongoose = require('mongoose');

// This sub-schema defines the structure of each item within a PO.
// Every item must be linked to an inventory item document.
const poItemSchema = new mongoose.Schema({
    item: { 
        type: mongoose.Schema.Types.ObjectId, 
        ref: 'Inventory', 
        required: true 
    },
    // We store these fields for historical data, in case the original inventory item's
    // name or SKU is changed in the future.
    name: { 
        type: String, 
        required: true 
    },
    sku: { 
        type: String, 
        required: true 
    },
    quantity: { 
        type: Number, 
        required: [true, 'Item quantity is required.'], 
        min: [1, 'Quantity must be at least 1.'] 
    },
    unitPrice: { 
        type: Number, 
        required: [true, 'Item unit price is required.'], 
        min: [0, 'Unit price cannot be negative.'] 
    },
}, { _id: false });


const purchaseOrderSchema = new mongoose.Schema({
    // This field is automatically generated by the static method below.
    // The `unique` and `index` constraints are critical for performance and data integrity.
    orderNumber: { 
        type: String, 
        required: true, 
        unique: true, 
        index: true 
    },
    
    supplier: { 
        type: mongoose.Schema.Types.ObjectId, 
        ref: 'Supplier', 
        required: true 
    },

    items: [poItemSchema],
    
    status: {
        type: String,
        required: true,
        enum: ['Pending', 'Ordered', 'Shipped', 'Completed', 'Cancelled'],
        default: 'Pending',
    },

    // Date tracking
    orderDate: { type: Date, default: Date.now },
    expectedDate: { type: Date },
    receivedDate: { type: Date },
    
    // Financials
    subtotal: { type: Number, required: true, default: 0 },
    taxAmount: { type: Number, default: 0 },
    shippingCost: { type: Number, default: 0 },
    totalAmount: { type: Number, required: true, default: 0 },
    
    // Additional Details
    paymentTerms: { type: String, default: 'net30' },
    notes: { type: String, trim: true, default: '' },

}, { 
    // Mongoose options to automatically add `createdAt` and `updatedAt` fields.
    timestamps: true 
});


/**
 * @statics generateOrderNumber
 * A static helper method on the PurchaseOrder model to create a new, unique
 * sequential order number. This is the definitive fix for the E11000 error.
 */
purchaseOrderSchema.statics.generateOrderNumber = async function() {
    try {
        // `this` refers to the PurchaseOrder model itself.
        // Find the PO with the highest `orderNumber` by sorting alphanumerically in descending order.
        const lastPO = await this.findOne().sort({ orderNumber: -1 });
        
        let nextOrderNum = 1; // Default starting number if no POs exist.

        if (lastPO && lastPO.orderNumber) {
            // Extract the numeric part from the last order number (e.g., '00002' from 'PO-00002').
            const lastNumStr = lastPO.orderNumber.split('-')[1];
            
            // Safely parse the string to a number and increment it.
            if (lastNumStr && !isNaN(parseInt(lastNumStr))) {
                nextOrderNum = parseInt(lastNumStr) + 1;
            }
        }
        
        // Format the new number with 5 leading zeros (e.g., 3 becomes '00003').
        return `PO-${String(nextOrderNum).padStart(5, '0')}`;

    } catch (error) {
        console.error("Fatal error in generateOrderNumber:", error);
        // Propagate the error up to the route's catch block for a clean 500 response.
        throw new Error("Could not generate a unique order number due to a database error.");
    }
};

module.exports = mongoose.model('PurchaseOrder', purchaseOrderSchema);